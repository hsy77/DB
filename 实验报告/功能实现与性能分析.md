# 功能实现与性能分析

所有功能实现的数据库增删改查操作使用orm包装，避免sql注入，保障安全性，且实现了事务处理。

## user功能

**1.用户注册register**

功能实现：

1. 根据user_id判断该用户名是否已经存在。若已存在通error.error_exist_user_id(user_id)返回错误信息
2. 插入user_id、password、balance、token、termial信息至usr表。其中terminal由terminal_当前时间表示。token由jwt_encode生成。

性能分析：
         usr表一次根据user_id主键查询，一次插入。

**2.用户注销unregister**

功能实现：

1. 根据user_id查询该user是否存在。若不存在由error.error_authorization_fail()返回错误信息
2. 判断用户输入密码是否正确。若不正确由error.error_authorization_fail()返回错误信息
3. 删除根据user_id对应usr表中条目。

性能分析：
         usr表一次根据user_id主键查询，一次删除。

**3.用户登录login**

功能实现：

1. 根据user_id获取用户密码。
2. 与用户输入密码对比。若比对失败返回错误信息
3. 密码对比成功，更新usr中的token，terminal。

性能分析：
          usr表一次根据user_id主键查询，一次更新。

**4.用户登出logout**

功能实现：

1. 根据user_id调用check_token查询该user是否处于登陆状态。
2. 如果处于登陆状态则更新token。

性能分析：
           usr表一次根据user_id主键查询，一次更新。

**5.更改密码change_password**

功能实现：

1. 根据user_id获取用户原有密码,与用户输入的旧密码对比
2. 若比对成功，更新用户密码为当前输入的密码。

性能分析：
            usr表一次根据user_id主键查询，一次更新。

## buyer功能

**1.下单new_order**

功能实现：

1. 首先保证用户id和storeid存在，若不存在返回对应用户信息
2. 通过user_id，store_id，和唯一标识符相连生成uid
3. 根据订单信息在store表中查找商户中是否存在对应书籍和足够的库存。
4. 若满足对应条件，则在store中的库存减去下单的数量，并向new_order_detail表插入order_id,book_id,buyer_id,store_id,count,price属性信息
5. 记录下单时间，将订单信息插入new_order_unpaid

性能分析：

​         store表k次根据主键查询，k次更新，new_order_detail表k次插入，(k为订单中购买的书本数）new_order_unpaid表一次插入。

**2.支付payment**

功能实现：

1. 查询在new_order_unpaid表中是否存在属于用户的待付订单，获取订单总价，商户id。
2. 若存在，根据user_id获取用户密码。并与用户输入密码对比。
3. 比对成功，且用户余额大于待付价格，则付款成功，否则失败，返回对应错误信息。
4. 若付款成功，在usr表中给给买家减少余额，根据卖家id给增加卖家的余额
5. 在new_order_unpaid表中删除对应的待付订单信息
6. 记录当前时间，在待发货表new_order_undelivered表中加入订单信息和付款时间。

性能分析：
         new_order_unpaid表一次根据主键order_id查询，一次删除，user表两次根据主键user_id查询，两次更新（其中一次买家、一次卖家）new_order_undelivered表一次插入。

**3.买家充值add_funds**

功能实现：

1. 根据user_id获取用户信息，若记录不存在，返回error_authorization_fail()
2. 将密码与用户输入密码比对
3. 若密码正确，在usr表中更新用户余额。否则返回相应报错

性能分析：  

​         usr表一次根据主键user_id查询，一次更新。

**4.买家收货receive_book**

功能实现：

1. 根据传入的参数user_id获取用户信息，若记录不存在，返回`error.error_non_exist_user_id()`
2. 根据传入的参数order_id判断待收货的表里是否存在该记录，如果不存在，就返回`error_invalid_order_id(order_id)`
3. 判断订单中的买家和传入的buyer_id是否一致，如果不一致就返回`error_authorization_fail()`
4. 若订单存在，买家存在且匹配，在待收货表new_order_unreceived中添加买家收货的时间。

性能分析：

​		usr表一次查询；

​		new_order_unreceived表一次查询，一次更新。

测试用例：

1. 买家user_id不存在；

2. 订单order_id不存在；

3. 买家id存在但不匹配；

4. 买家和订单都存在，且相互匹配。

**5.查询历史订单信息**

​        为支持不同的查询订单需求，函数接口中除buyer_id另增加flag。类似淘宝查询界面，支持查询用户所有订单，待付款订单，已付款待发货订单，已发货待收货订单，已收货订单，已取消订单。通过flag进行区分。

功能实现：

查所有订单

1. 若用户不存在返回对应错误信息
2. 根据buyer_id查询new_order_detail
3. 查询成功，返回订单order_id，buyer_id，store_id，book_id，count和price信息。

查待待付款订单

1. 根据buyer_id和下单时间不为空在new_order_unpaid表中筛选记录
2. 对每一条记录，根order_id查询New_order_detail表，获取订单id，所购书籍列表（每本书的书名，价格，数量），下单时间，订单状态。
3. 将获取的记录包装成json对象，每个order下包含由订单id,下单时间，订单状态，所购书籍列表（书名，价格，数量）构成的数组。

查询已付款待发货订单，已发货待收货订单，已收货订单，已取消订单与查待待付款订单过程类似。只是返回订单状态不同，不再赘述。

性能分析：

​      查所有订单：new_order_unpaid表一次查询

​      查询待付款订单：new_order_unpaid表一次查询，对应new_order_detail表k次根据主键查询（k为new_order_unpaid的该用户待付记录数）

​      查询已付款待发货订单：new_order_undelivered表一次查询，对应new_order_undelivered表k次根据主键查询（k为new_order_undelivered的该用户待发货记录数）

​      查询已发货待收货订单：new_order_unreceived表一次查询，对应new_order_detail表k次根据主键查询（k为new_order_unreceived的该用户待收货记录数）

​     查询已取消订单：new_order_canceled表一次查询，对应new_order_canceled表k次根据主键查询（k为new_order_canceled的该用户已取消记录数）

 测试用例：

1. 正常情况（包括所有订单，待付款订单，已付款待发货订单，已发货待收货订单，已收货订单，已取消订单能否正常返回）
2. user_id不存在的情况
3. 用户无购买记录

**6.手动取消订单**

根据淘宝，如果卖家已发货需要申请售后来取消订单，这里我们只允许在未发货或未付款情况下才能取消订单

功能实现：

1. 根据order_id和buyer_id在new_order_unpaid中判断是否为待付款订单
2. 若是，在new_order_unpaid中删除对应订单
3. 根据order_id和buyer_id在new_order_undeliverd中判断是否为待发货订单
4. 确定订单未发货后。在usr表中更新买家余额增加该订单对应款项。
5. 在usr表中更新卖家余额减少该订单对应款项。
6. 在待发货表中删除对应记录。
7. 记录当前时间并将订单信息加入new_order_cancel表中。
8. 判断New_order_detail中的order_id是否为用户输入order_id，book_id是否与store对应，在new_order_detail表中筛选记录，在store表中将对应的书籍的库存加回。
9. 若不是上述两种情况，返回无法取消订单

性能分析：

​           new_order_unpaid表一次查询，一次删除，new_order_undelivered表一次查询，一次删除，new_order_cancel表一次插入，new_order_detail表一次查询，store表k次更新（k为购买书籍数），user表两次根据user_id主键查询，两次更新（一次买家、一次卖家）。 

测试用例： 

1. 已付款待发货
2. 未付款
3. user_id不存在
4. 已发货

**7，自动取消订单**

使用技术：

Redis键空间通知（过期回调）用户下单之后将订单id作为key，任意值作为值存入redis中，给这条数据设置过期时间，也就是订单超时的时间。

1，下载安装redis（电脑中和python中）

（以下方法仅针对windows电脑）

- 在redis文件中使用`redis-server.exe redis.windows.conf`启动redis

- 设置`redis.windows.conf`中的`notify-keyspace-events "EX"`（为了保证可以发出过期数据的数据）

  我们会收到关键事件通知，在keyevent频道中，我们会收到key作为消息。

- 可使用`redis-cli.exe --csv psubscribe '*' `测试服务是否打开

2，在python中使用redis，配置回调函数

注册回调函数来处理已发布的消息。消息处理程序只接受一个参数即消息。要使用消息处理程序订阅通道或模式，请将通道或模式名称作为关键字参数传递，其值为回调函数。当使用消息处理程序在通道或模式上读取消息时，将创建消息字典并将其传递给消息处理程序。在这种情况下，从*get_message（）*返回*None*值，因为消息已经处理完毕。

功能实现：

1. 在buyer()中的new_order函数中将订单号存入redis数据库中，并设置超时时间

2. 在回调函数auto_cancel_order中设置死循环，每当接收到一个过期数据，就将order_id解析出来。

3. 通过这个order_id判断能否找到未支付订单new_order_unpaid中的数据，
4. 如果存在，将其删除，在已取消订单new_order_canceled中添加该order和取消时间。
5. 如果不存在，说明该订单已被支付或者买家主动取消订单，则什么都不用处理。

```python
#连接redis数据库
r=redis.StrictRedis(host='localhost',port=6379,db=0,decode_responses=True)
# 创建pubsub对象，该对象订阅一个频道并侦听新消息：
pubsub=r.pubsub()
#收到消息的处理函数
 def event_hander(msg):
    # print('Handler',msg)
    order_id=str(msg['data'])
    print(order_id)
    #如果能找到订单，就删除未支付订单
    #添加到已删除订单中 
    #将商店中的书籍书加回去
#订阅过期数据
pubsub.psubscribe(**{'__keyevent@0__:expired':event_hander})
#死循环，当有数据过期时，调用函数event_hander处理过期数据
while True:
    # print("监控超时订单")
    #获得事件信息，有结果就会回调函数
    message=pubsub.get_message()
    time.sleep(0.1)
```

性能分析：

​           redis数据库一次更新（插入数据）。 

​			当接收到数据时，对new_order_unpaid一次查找；

​			当数据存在，对new_order_unpaid一次更新；对new_order_canceled一次更新。

测试用例： 

1. 未支付订单中超时
2. 未支付订单未超时

使用方法：

单独开一个进程运行自动取消订单的程序，然后再运行服务器app.py，可实现自动取消订单。测试也能够通过

- 如果不测试自动取消订单，将model1中带注释的代码注掉，然后再把test文件中的test_auto_model.py文件注掉，方便测试（因测试自动取消订单需要等待20s，如果不测试自动取消就没有必要）



## seller功能

**1.上架图书add_book**

实现两种版本可支持只上架图书，或可将书籍添加到book表中并上架图书（该版本可以不运行book.py导入数据，通过add_book函数插入书籍）

这里传参接口增加price属性，需要商家自己定价，而不是传入书籍的零售价。

版本1:

1. 检查user_id，store_id以及book_id是否已存在。若不存在返回对应错误信息
2. 将store_id, book_id, 出售价格插入store表。

性能分析：
         usr表一次根据主键user_id查询，store表一次根据主键store_id查询，book表一次根据主键book_id查询，store表一次插入。

版本2:

1. 在版本一的基础上增加根据book_id从book表查询判断书是否已经在book表中
2. 如果不在，插入书籍的所有信息

注意该版本事务add_book是包括添加图书，将书籍添加到商店这两步

我们初始代码是两步结束后才commit，就导致第一步的图书还没添加进去，就在做第二步的将书籍添加到商店,而因为store里面的book_id必须存在在book表中，在重建数据库测试时会出现问题。在添加完图书（做完第一步）之后添加self.session.commit()即可解决

性能分析：

​       usr表一次根据主键user_id查询，store表一次根据主键store_id查询，book表一次根据主键book_id查询,一次插入，store表一次插入。

**2.创建店铺create_store**

1. 检查user_id和store_id是否已存在。若不存在返回对应错误信息
2. 插入用户id，新建店铺store_id至user_store表。

性能分析：
        usr表一次根据主键user_id查询，store表一次根据主键store_id查询，user_store表一次插入。

**3.添加库存add_stock_level**

1. 检查user_id、store_id和book_id是否已存在。若不存在返回对应错误信息
2. 根据store_id, book_id对store表查询卖家商店中的书籍库存量，并在store表中更新库存，加上传入的库存数。

性能分析：
        usr表一次根据主键user_id查询，store表一次根据store_id主键查询，一次更新。

**4.卖家发货deliver_book**

1. 功能实现：

   1. 根据传入的参数user_id获取用户信息，若记录不存在，返回`error.error_non_exist_user_id()`
   2. 根据传入的参数order_id判断待发货的表里是否存在该记录，如果不存在，就返回`error_invalid_order_id(order_id)`
   3. 判断订单中的卖家和传入的seller_id是否一致，如果不一致就返回`error_authorization_fail()`
   4. 若订单存在，卖家存在且匹配，在待发货表new_order_undelivered删除该订单，在待收货表new_order_unreceived中添加该订单和发货时间。

   性能分析：

   ​		usr表一次查询；

   ​		new_order_undelivered表一次查询，一次更新。

   ​		new_order_unreceived表一次更新。

   测试用例：

   1. 买家user_id不存在；

   2. 订单order_id不存在；

   3. 卖家id存在但不匹配；

   4. 卖家和订单都存在，且相互匹配。



## 实验过程中遇到的问题和解决方法

**1.VScode中误报(import-error)解决**

在vscode中点击文件->首选项->设置，在搜索框中输入：pylintArgs

在搜索的结果Python>Linting:Pylint Args中点击添加项，分别添加—errors-only已及—disable=E0401，保存，退出设置，重启vscode既可解决

![w1.png](http://ww1.sinaimg.cn/large/005ZSk16ly1gml7fqbqrzj31ng0h2q6x.jpg)

**2.user_id = request.json.get("user_id", "")**
**AttributeError: 'NoneType' object has no attribute 'get'**

postman测试的body没有设置为json格式导致前端无法解析

**3."'tuple' object has no attribute 'keys'"**

![w2.png](http://ww1.sinaimg.cn/large/005ZSk16ly1gml7gd6vexj31ls0gagox.jpg)

由于数据库语句书写格式错误，如应该应该是set xx,xx写出set xx and xx等

`"UPDATE usr set token= '%s' , terminal = '%s' where user_id = '%s'"`

**4.init_db文件夹中的book.py是插入书籍信息，但在vscode无法访问路径。**

将`self.book_db `改为绝对路径

**5.当运行测试时会报530error，发现无法插入数据**

将所有表中的`user_id，store_id，buy_id`改为256的str，`order_id`改为512的str(因为测试过程中生成的用户名和店铺名为长度为159的str，生成的订单是买家名和店铺名的join，因此需要设置长一点的str)

**6.运行init_database.py文件导入数据时会报错，键值不存在**

将每个表中的插入都commit，以免出现键值不存在的情况

```python
session.add_all([
        Users(user_id = 'search',
            password = '123456',
            balance = 9000,
            token = '***',
            terminal='Edge'),
    ])
    session.commit()
    session.add(User_store(user_id = 'search',
                store_id = 'Kadokawa'))
                #store_id相当于商店名)
    session.commit()
    session.add_all([
        Store(store_id = 'Kadokawa',
                    book_id = 50,
                    stock_level=10,
                    price=2599)
    ])
    session.commit()
```



## 实验总结

善于利用postman测试代码中的问题

善于使用测试文件检验代码是否具有高可用性(测试驱动开发)